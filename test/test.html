<!DOCTYPE html>

<script src="../src/mutation_events.js"></script>

<h3>Mutation Events Polyfill Test</h3>

<div id=parent>
  <div id=target></div>
  <div id=other></div>
</div>

<table id=log></table>

<style>
  #log td:nth-child(1) {
    padding: 0 2em 0 0;
  }
  #log td:nth-child(2) {
    word-wrap: break-word;
    white-space: pre-wrap;
    padding-left: 2em;
    text-indent: -2em;
    width:100%;
  }
  td.pass {
    background-color: lightgreen;
  }
  td.fail {
    background-color: red;
  }
  html,body {
    width: 100%;
  }
</style>

<script>
const nativelySupported = "MutationEvent" in window;
function getDescription(n) {
  if (typeof n !== 'object' || n === null) {
    return String(n);
  } else if (n.nodeType === 3) {
    return `Text node ${n.textContent}`;
  } else if (n.hasAttribute('id')) {
    return n.id;
  } else {
    return n.outerHTML;
  }
}
function addResult(success,msg) {
  const newRow = document.createElement('tr');
  newRow.innerHTML = `<td class=${success ? 'pass' : 'fail'}>${success ? 'PASS' : 'FAIL'}</td><td>${msg}</td>`;
  document.getElementById('log').appendChild(newRow);
}
const eventProperties = [
  'type',
  'target',
  'currentTarget',
  'bubbles',
  'cancelable',
  'eventPhase',
  'attrChange',
  'newValue',
  'prevValue',
  /* Things we can't do with the polyfill: */
  // 'relatedNode',
]
function assert(val,msg) {
  if (!val) {
    console.log('=====> FAIL! ',msg);
    addResult(false,msg);
  }
  return val;
}
function assert_events_equal(actualEvents,expectedEvents,description) {
  if (!assert(Array.isArray(actualEvents) && Array.isArray(expectedEvents),`${description}: Both must be arrays`))
    return false;
  if (!assert(actualEvents.length === expectedEvents.length,`${description}: Different number of events received. ${actualEvents.length} vs ${expectedEvents.length}`))
    return false;
  for(let i=0;i<actualEvents.length;++i) {
    let pass=true;
    for(let property of eventProperties) {
      let eventDescription = `event #${i}`;
      if (property !== 'type') {
        eventDescription += ` (${expectedEvents[i].type})`;
      }
      pass = assert(property in actualEvents[i],`${description}: ${eventDescription} actual should have property ${property}`) && pass;
      pass = assert(property in expectedEvents[i],`${description}: ${eventDescription} expected should have property ${property}`) && pass;
      const actual = getDescription(actualEvents[i][property]);
      const expected = getDescription(expectedEvents[i][property]);
      pass = assert(actual === expected,`${description}: ${eventDescription} mismatch for ${property}, actual ${actual} vs. expected ${expected}`) && pass;
    };
    if (!pass)
      return false;
  }
  return true;
}

const target = document.getElementById('target');
target.textContent = "Hello";
const parent = document.getElementById('parent');
const events = [
  'DOMCharacterDataModified',
  'DOMNodeInserted',
  'DOMNodeInsertedIntoDocument',
  'DOMNodeRemoved',
  'DOMNodeRemovedFromDocument',
  'DOMSubtreeModified',
];

let eventLog = [];
let expectAllEmpty = false;
let expectTrustedEvents = nativelySupported;

async function waitFrame() {
  await new Promise((resolve) => requestAnimationFrame(resolve));
}
async function waitAndCheck(expected, description) {
  await waitFrame();
  const success = assert_events_equal(eventLog,expectAllEmpty ? [] : expected,description);
  eventLog = [];
  return success;
}
async function testOne(state, description, expectedEvents, action) {
  description = `(${state}) ${description}`;
  console.log(`--> ${description}`);
  await action();
  const success = await waitAndCheck(expectedEvents, description);
  if (success) {
    addResult(true,description);
  }
}

async function testHarness() {
  // Test for mutation events, with and without polyfill

  events.forEach(evt => {
    target.addEventListener(evt,(e) => {
      assert(e.isTrusted === expectTrustedEvents,'trusted event mismatch: ' + e.isTrusted)
      console.log(`Received ${e.type} on ${getDescription(e.target)}`);
      let eventCopy = {};
      for (property of eventProperties) {
        eventCopy[property] = e[property];
      }
      eventLog.push(eventCopy);
    })
  });

  let left=2;
  let state = nativelySupported ? 'Native feature' : 'Polyfill ENABLED';
  while (left) {
    // Run all of the tests:
    await runAllTests(state);

    // Cleanup
    parent.appendChild(target);
    target.removeAttribute('test');
    target.replaceChildren(document.createTextNode('Hello'));
    assert(target.parentNode === parent,'target wasn\'t put back after tests');
    assert(target.outerHTML === '<div id="target">Hello</div>','target has extra attributes: ' + target.outerHTML);
    eventLog = [];

    if (left) {
      // Now disable and check that the correct thing happens
      disableMutationEventPolyfillForTesting(target);
      // If mutation events are natively supported, expect the same events.
      // If not, expect no events after the polyfill is disabled.
      if (!nativelySupported) {
        console.log('Mutation Events NATIVELY DISABLED - verifying no events');
        state = 'Polyfill DISABLED';
        expectAllEmpty = true;
      } else {
        console.log('Mutation Events NATIVELY ENABLED - verifying the same events are fired');
        state = 'Native feature (retry)';
        assert(expectTrustedEvents,'problem');
      }
      --left;
    }
  }
  parent.remove();
}

const baseEventObj = {
  attrChange: 0, bubbles: true, cancelable: false, eventPhase: 2, newValue: '', prevValue: '', relatedNode: null
}
function eventObj(type, target, overrides) {
  let newEvent = Object.assign({}, baseEventObj);
  newEvent.type = type;
  newEvent.target = target;
  newEvent.currentTarget = target;
  for(prop in overrides) {
    newEvent[prop] = overrides[prop];
  }
  return newEvent;
}

async function runAllTests(state) {
  await testOne(state,'Node removal',[
      eventObj('DOMNodeRemoved','target',{relatedNode: parent}),
      eventObj('DOMNodeRemovedFromDocument','target',{bubbles:false})
    ],
    () => target.remove());

  await testOne(state,'Node append',[
      eventObj('DOMNodeInserted','target',{relatedNode: other}),
      eventObj('DOMNodeInsertedIntoDocument','target',{bubbles:false})
    ],
    () => other.appendChild(target));

  await testOne(state,'Create attribute',[
      eventObj('DOMSubtreeModified','target'),
    ],
    () => target.setAttribute('test','foo'));

  await testOne(state,'Change attribute value',[],
    () => target.setAttribute('test','bar'));

  await testOne(state, 'Change attribute value (direct)',[],
    () => {target.attributes[1].value = 'bar'});

  await testOne(state,'Remove attribute',[
      eventObj('DOMSubtreeModified','target'),
    ],
    () => target.removeAttribute('test'));

  await testOne(state,'Replace children',[
      eventObj('DOMNodeRemoved','Text node Hello',{relatedNode: target, currentTarget: target, eventPhase: 3}),
      eventObj('DOMSubtreeModified','target'),
      eventObj('DOMNodeInserted','Text node Hello there',{relatedNode: target, currentTarget: target, eventPhase: 3}),
      eventObj('DOMSubtreeModified','target'),
    ],
    () => target.replaceChildren(document.createTextNode('Hello there')));

  await testOne(state, 'Replace text content',[
      eventObj('DOMCharacterDataModified','Text node foo',{currentTarget: target, eventPhase: 3, newValue: 'foo', prevValue: 'Hello there'}),
      eventObj('DOMSubtreeModified','Text node foo',{currentTarget: target, eventPhase: 3}),
    ],
    () => target.firstChild.textContent = "foo");

  await testOne(state, 'Append child node',[
      eventObj('DOMNodeInserted','div', {relatedNode: target, currentTarget: target, eventPhase: 3}),
      eventObj('DOMSubtreeModified','target'),
    ],
    () => {
      const div = document.createElement('div');
      div.id = 'div';
      target.appendChild(div);
    });

  await testOne(state, 'Create child node attribute',[
      eventObj('DOMSubtreeModified','div',{currentTarget: target, eventPhase: 3}),
    ],
    () => div.setAttribute('foo','bar'));
}

testHarness();

</script>
