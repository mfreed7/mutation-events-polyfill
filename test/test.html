<!DOCTYPE html>

<script>
// Test settings
const testInsertedRemovedDocument = true; // Set to true to test DOMNodeInsertedIntoDocument and DOMNodeRemovedFromDocument events (false for Firefox)
const testCaptureBubbleOrder = true; // Set to true to test the order of capture and bubble (false for Firefox)
</script>

<script src="../src/mutation_events.js"></script>

<h3>Mutation Events Polyfill Test</h3>
<h1 class=hide>Mutation Events are <u>enabled</u> in this browser. This test will
    therefore only be testing the <u>native</u> implementation of Mutation
    Events and <u>not the polyfill</u>.</h1>
<h3 class=hide>In Chromium, the native behavior can be disabled via the flag
  <code>chrome://flags/#mutation-events</code>.
</h3>
<div id=parent>
  <div id=target></div>
  <div id=other></div>
</div>
<table id=log></table>

<style>
  #log td:nth-child(1) {
    padding: 0 2em 0 0;
  }
  #log td:nth-child(2) {
    word-wrap: break-word;
    white-space: pre-wrap;
    padding-left: 2em;
    text-indent: -2em;
    width:100%;
  }
  td.pass {
    background-color: lightgreen;
  }
  td.fail {
    background-color: red;
  }
  html,body {
    width: 100%;
  }
  .hide {
    display:none;
  }
</style>

<script>
const nativelySupported = "MutationEvent" in window;
if (nativelySupported) {
  document.querySelectorAll('.hide').forEach(el => el.classList.remove('hide'));
}
function getDescription(n) {
  if (typeof n !== 'object' || n === null) {
    return String(n);
  } else if (n.nodeType === 3) {
    return `Text node ${n.textContent}`;
  } else if (n.hasAttribute('id')) {
    return n.id;
  } else {
    return n.outerHTML;
  }
}
function addResult(success,msg) {
  const newRow = document.createElement('tr');
  newRow.innerHTML = `<td class=${success ? 'pass' : 'fail'}>${success ? 'PASS' : 'FAIL'}</td><td>${msg}</td>`;
  document.getElementById('log').appendChild(newRow);
}
const eventProperties = [
  'type',
  'target',
  'isTrusted',
  'capture',
  'currentTarget',
  'bubbles',
  'cancelable',
  'attrChange',
  'newValue',
  'prevValue',
  /* Things we can't do with the polyfill: */
  // 'relatedNode',
]
function assert(val,msg) {
  if (!val) {
    console.log('=====> FAIL! ',msg);
    addResult(false,msg);
  }
  return val;
}
function assert_events_equal(actualEvents,expectedEvents,description) {
  if (!assert(Array.isArray(actualEvents) && Array.isArray(expectedEvents),`${description}: Both must be arrays`))
    return false;
  let pass = assert(actualEvents.length === expectedEvents.length,`${description}: Different number of events received. actual ${actualEvents.length} vs expected ${expectedEvents.length}`);
  const len = Math.min(actualEvents.length,expectedEvents.length);
  for(let i=0;i<len;++i) {
    for(let property of eventProperties) {
      let eventDescription = `event #${i}`;
      if (property !== 'type') {
        eventDescription += ` (${expectedEvents[i].type})`;
      }
      pass = assert(property in actualEvents[i],`${description}: ${eventDescription} actual should have property ${property}`) && pass;
      pass = assert(property in expectedEvents[i],`${description}: ${eventDescription} expected should have property ${property}`) && pass;
      const actual = getDescription(actualEvents[i][property]);
      const expected = getDescription(expectedEvents[i][property]);
      if (testCaptureBubbleOrder || property !== 'capture')
      pass = assert(actual === expected,`${description}: ${eventDescription} mismatch for ${property}, actual ${actual} vs. expected ${expected}`) && pass;
    };
    if (!pass)
      return false;
  }
  return pass;
}

const target = document.getElementById('target');
target.textContent = "Hello";
const parent = document.getElementById('parent');
const events = [
  'DOMCharacterDataModified',
  'DOMNodeInserted',
  'DOMNodeInsertedIntoDocument',
  'DOMNodeRemoved',
  'DOMNodeRemovedFromDocument',
  'DOMSubtreeModified',
];

let eventLog = [];
let expectAllEmpty = false;
let expectTrustedEvents = nativelySupported;

async function waitFrame() {
  await new Promise((resolve) => requestAnimationFrame(resolve));
}
async function waitAndCheck(expected, description) {
  await waitFrame();
  if (!testInsertedRemovedDocument) {
    const filter = e => (e.type !== 'DOMNodeInsertedIntoDocument' && e.type !== 'DOMNodeRemovedFromDocument');
    eventLog = eventLog.filter(filter);
    expected = expected.filter(filter);
  }
  const success = assert_events_equal(eventLog,expectAllEmpty ? [] : expected,description);
  eventLog = [];
  return success;
}
async function testOne(state, description, eventsList, expectedEventOrder, action) {
  description = `(${state}) ${description}`;
  console.log(`--> ${description}`);
  let expectedEvents = [];
  for(let eventItem of expectedEventOrder) {
    const event = Object.assign({},eventsList[eventItem[0]]);
    expectedEvents.push(Object.assign(event,{currentTarget: eventItem[1], capture: eventItem[2]==='capture'}));
  }
  await action();
  const success = await waitAndCheck(expectedEvents, description);
  if (success) {
    addResult(true,description);
  }
}

async function testHarness() {
  // Test for mutation events, with and without polyfill

  events.forEach(evt => {
    function listener(capture) {
      return (e) => {
        console.log(`Received ${e.type} (${capture ? 'capture' : 'bubble'}) on ${getDescription(e.currentTarget)}, target is ${getDescription(e.target)}`);
        let eventCopy = {};
        for (property of eventProperties) {
          eventCopy[property] = e[property];
        }
        eventCopy.capture = capture;
        eventLog.push(eventCopy);
      }
    }
    target.addEventListener(evt,listener(false),{capture: false});
    target.addEventListener(evt,listener(true),{capture: true});
    parent.addEventListener(evt,listener(false),{capture: false});
    parent.addEventListener(evt,listener(true),{capture: true});
  });

  let left=2;
  let state = nativelySupported ? 'Native feature' : 'Polyfill ENABLED';
  while (left) {
    // Run all of the tests:
    await runAllTests(state);

    // Cleanup
    parent.appendChild(target);
    target.removeAttribute('test');
    target.replaceChildren(document.createTextNode('Hello'));
    assert(target.parentNode === parent,'target wasn\'t put back after tests');
    assert(target.outerHTML === '<div id="target">Hello</div>','target has extra attributes: ' + target.outerHTML);
    eventLog = [];

    if (left) {
      // Now disable and check that the correct thing happens
      disableMutationEventPolyfillForTesting(target);
      disableMutationEventPolyfillForTesting(parent);
      // If mutation events are natively supported, expect the same events.
      // If not, expect no events after the polyfill is disabled.
      if (!nativelySupported) {
        console.log('Mutation Events NATIVELY DISABLED - verifying no events');
        state = 'Polyfill DISABLED';
        expectAllEmpty = true;
      } else {
        console.log('Mutation Events NATIVELY ENABLED - verifying the same events are fired');
        state = 'Native feature (retry)';
        assert(expectTrustedEvents,'problem');
      }
      --left;
    }
  }
  parent.remove();
}

const baseEventObj = {
  attrChange: 0, bubbles: true, cancelable: false, newValue: '', prevValue: '', relatedNode: null
}
function eventObj(type, target, overrides) {
  let newEvent = Object.assign({}, baseEventObj);
  newEvent.type = type;
  newEvent.target = target;
  newEvent.isTrusted = expectTrustedEvents;
  for(prop in overrides) {
    newEvent[prop] = overrides[prop];
  }
  return newEvent;
}

// testOne tests a single kind of mutation, and looks for the expected set of
// events.
//   testOne(state,description_of_test_case,[
//       // list of unique event types fired, e.g.
//       eventObj(event_name,target,{event_settings}),
//       eventObj('DOMNodeRemoved','target',{relatedNode: parent}),
//     ],[
//       // list of actual events fired, at which targets, in what phase, e.g.
//       [index_into_unique_events_list, currentTarget, eventPhase],
//       [0, 'parent', 'capture'],
//       [0, 'target'],
//     ],
//       // DOM mutation lambda, e.g.
//       () => target.remove()
//   );

async function runAllTests(state) {
  await testOne(state,'Node removal',[
      eventObj('DOMNodeRemoved','target',{relatedNode: parent}),
      eventObj('DOMNodeRemovedFromDocument','target',{bubbles:false}),
      eventObj('DOMNodeRemovedFromDocument','Text node Hello',{bubbles:false}),
      eventObj('DOMSubtreeModified','parent'),
    ],[
      [0, 'parent', 'capture'],
      [0, 'target', 'capture'],
      [0, 'target'],
      [0, 'parent'],
      [1, 'parent', 'capture'],
      [1, 'target', 'capture'],
      [1, 'target'], // DOMNodeRemovedFromDocument doesn't bubble
      [2, 'parent', 'capture'],
      [2, 'target', 'capture'],
      [3, 'parent', 'capture'],
      [3, 'parent'],
    ],
    () => target.remove());

  await testOne(state,'Node append',[
      eventObj('DOMNodeInserted','target',{relatedNode: other}),
      eventObj('DOMNodeInsertedIntoDocument','target',{bubbles:false}),
      eventObj('DOMNodeInsertedIntoDocument','Text node Hello',{bubbles:false}),
      eventObj('DOMSubtreeModified','other'),
    ], [
      [0, 'parent', 'capture'],
      [0, 'target', 'capture'],
      [0, 'target'],
      [0, 'parent'],
      [1, 'parent', 'capture'],
      [1, 'target', 'capture'],
      [1, 'target'], // DOMNodeInsertedIntoDocument doesn't bubble
      [2, 'parent', 'capture'],
      [2, 'target', 'capture'],
      [3, 'parent', 'capture'],
      [3, 'parent'],
    ],
    () => other.appendChild(target));

  await testOne(state,'Create attribute',[
      eventObj('DOMSubtreeModified','target'),
    ], [
      [0, 'parent', 'capture'],
      [0, 'target', 'capture'],
      [0, 'target'],
      [0, 'parent'],
    ],
    () => target.setAttribute('test','foo'));

  await testOne(state,'Change attribute value',[], [],
    () => target.setAttribute('test','bar'));

  await testOne(state, 'Change attribute value (direct)',[], [],
    () => {target.attributes[1].value = 'bar'});

  await testOne(state,'Remove attribute',[
      eventObj('DOMSubtreeModified','target'),
    ], [
      [0, 'parent', 'capture'],
      [0, 'target', 'capture'],
      [0, 'target'],
      [0, 'parent'],
    ],
    () => target.removeAttribute('test'));

  await testOne(state,'Replace children',[
      eventObj('DOMNodeRemoved','Text node Hello',{relatedNode: target}),
      eventObj('DOMNodeRemovedFromDocument','Text node Hello',{relatedNode: target, bubbles:false}),
      eventObj('DOMSubtreeModified','target'),
      eventObj('DOMNodeInserted','Text node Hello there',{relatedNode: target}),
      eventObj('DOMNodeInsertedIntoDocument','Text node Hello there',{relatedNode: target, bubbles:false}),
      eventObj('DOMSubtreeModified','target'),
    ], [
      [0, 'parent', 'capture'],
      [0, 'target', 'capture'],
      [0, 'target'],
      [0, 'parent'],
      [1, 'parent', 'capture'],
      [1, 'target', 'capture'],
      [2, 'parent', 'capture'],
      [2, 'target', 'capture'],
      [2, 'target'],
      [2, 'parent'],
      [3, 'parent', 'capture'],
      [3, 'target', 'capture'],
      [3, 'target'],
      [3, 'parent'],
      [4, 'parent', 'capture'],
      [4, 'target', 'capture'],
      [5, 'parent', 'capture'],
      [5, 'target', 'capture'],
      [5, 'target'],
      [5, 'parent'],
    ],
    () => target.replaceChildren(document.createTextNode('Hello there')));

  await testOne(state, 'Replace text content',[
      eventObj('DOMCharacterDataModified','Text node foo',{newValue: 'foo', prevValue: 'Hello there'}),
      eventObj('DOMSubtreeModified','Text node foo',{}),
    ], [
      [0, 'parent', 'capture'],
      [0, 'target', 'capture'],
      [0, 'target'],
      [0, 'parent'],
      [1, 'parent', 'capture'],
      [1, 'target', 'capture'],
      [1, 'target'],
      [1, 'parent'],
    ],
    () => target.firstChild.textContent = "foo");

  await testOne(state, 'Append child node',[
      eventObj('DOMNodeInserted','div', {relatedNode: target}),
      eventObj('DOMNodeInsertedIntoDocument','div', {relatedNode: target, bubbles: false}),
      eventObj('DOMSubtreeModified','target'),
    ], [
      [0, 'parent', 'capture'],
      [0, 'target', 'capture'],
      [0, 'target'],
      [0, 'parent'],
      [1, 'parent', 'capture'],
      [1, 'target', 'capture'],
      [2, 'parent', 'capture'],
      [2, 'target', 'capture'],
      [2, 'target'],
      [2, 'parent'],
    ],
    () => {
      const div = document.createElement('div');
      div.id = 'div';
      target.appendChild(div);
    });

  await testOne(state, 'Create child node attribute',[
      eventObj('DOMSubtreeModified','div',{currentTarget: target}),
    ], [
      [0, 'parent', 'capture'],
      [0, 'target', 'capture'],
      [0, 'target'],
      [0, 'parent'],
    ],
    () => div.setAttribute('foo','bar'));
}

testHarness();

</script>
