<!DOCTYPE html>

<script src="../src/mutation_events.js"></script>

<h3>Mutation Events Polyfill Test</h3>

<div id=parent>
  <div id=target></div>
  <div id=other></div>
</div>

<table id=log></table>

<style>
  #log td:nth-child(1) {
    padding: 0 2em 0 0;
  }
  #log td:nth-child(2) {
    word-wrap: break-word;
    white-space: pre-wrap;
    padding-left: 2em;
    text-indent: -2em;
    width:100%;
  }
  td.pass {
    background-color: lightgreen;
  }
  td.fail {
    background-color: red;
  }
  html,body {
    width: 100%;
  }
</style>

<script>
const nativelySupported = "MutationEvent" in window;
function getDescription(n) {
  if (typeof n !== 'object' || n === null) {
    return String(n);
  } else if (n.nodeType === 3) {
    return `Text node ${n.textContent}`;
  } else if (n.hasAttribute('id')) {
    return n.id;
  } else {
    return n.outerHTML;
  }
}
function addResult(success,msg) {
  const newRow = document.createElement('tr');
  newRow.innerHTML = `<td class=${success ? 'pass' : 'fail'}>${success ? 'PASS' : 'FAIL'}</td><td>${msg}</td>`;
  document.getElementById('log').appendChild(newRow);
}
function mutationEventToString(e) {
  return `${e.type}, target: ${getDescription(e.target)}, attrChange: ${e.attrChange}, ` +
      `bubbles: ${e.bubbles}, cancelable: ${e.cancelable}, ` +
      `currentTarget: ${getDescription(e.currentTarget)}, eventPhase: ${e.eventPhase}, ` +
      `newValue: "${e.newValue}", prevValue: "${e.prevValue}"` +
      /* Things we can't do with the polyfill: */
     // `, relatedNode: ${getDescription(e.relatedNode)}`;
     '';
}
function assert(val,msg) {
  if (!val) {
    console.log('=====> FAIL! ',msg);
    addResult(false,msg);
  }
  return val;
}
function assert_equals(actual,expected,description) {
  actual = JSON.stringify(actual);
  expected = JSON.stringify(expected);
  const diffStr = `${description}. Actual = ${actual}, expected = ${expected}`;
  return assert(actual === expected,diffStr)
}

const target = document.getElementById('target');
target.textContent = "Hello";
const parent = document.getElementById('parent');
const events = [
  'DOMCharacterDataModified',
  'DOMNodeInserted',
  'DOMNodeInsertedIntoDocument',
  'DOMNodeRemoved',
  'DOMNodeRemovedFromDocument',
  'DOMSubtreeModified',
];

let eventLog = [];
let expectAllEmpty = false;
let expectTrustedEvents = nativelySupported;

async function waitFrame() {
  await new Promise((resolve) => requestAnimationFrame(resolve));
}
async function waitAndCheck(expected, description) {
  await waitFrame();
  const success = assert_equals(eventLog,expectAllEmpty ? [] : expected,description);
  eventLog = [];
  return success;
}
async function testOne(state, description, expectedEvents, action) {
  description = `(${state}) ${description}`;
  console.log(`--> ${description}`);
  await action();
  const success = await waitAndCheck(expectedEvents, description);
  if (success) {
    addResult(true,description);
  }
}

async function testHarness() {
  // Test for mutation events, with and without polyfill

  events.forEach(evt => {
    target.addEventListener(evt,(e) => {
      assert(e.isTrusted === expectTrustedEvents,'trusted event mismatch: ' + e.isTrusted)
      console.log(`Received ${e.type} on ${getDescription(e.target)}`);
      eventLog.push(mutationEventToString(e))
    })
  });

  let left=2;
  let state = nativelySupported ? 'Native feature' : 'Polyfill ENABLED';
  while (left) {
    // Run all of the tests:
    await runAllTests(state);

    // Cleanup
    parent.appendChild(target);
    target.removeAttribute('test');
    target.replaceChildren(document.createTextNode('Hello'));
    assert(target.parentNode === parent,'target wasn\'t put back after tests');
    assert(target.outerHTML === '<div id="target">Hello</div>','target has extra attributes: ' + target.outerHTML);
    eventLog = [];

    if (left) {
      // Now disable and check that the correct thing happens
      disableMutationEventPolyfillForTesting(target);
      // If mutation events are natively supported, expect the same events.
      // If not, expect no events after the polyfill is disabled.
      if (!nativelySupported) {
        console.log('Mutation Events NATIVELY DISABLED - verifying no events');
        state = 'Polyfill DISABLED';
        expectAllEmpty = true;
      } else {
        console.log('Mutation Events NATIVELY ENABLED - verifying the same events are fired');
        state = 'Native feature (retry)';
        assert(expectTrustedEvents,'problem');
      }
      --left;
    }
  }
  parent.remove();
}

const baseEventObj = {
  attrChange: 0, bubbles: true, cancelable: false, eventPhase: 2, newValue: '', prevValue: '', relatedNode: null
}
function eventObj(type, target, overrides) {
  let newEvent = Object.assign({}, baseEventObj);
  newEvent.type = type;
  newEvent.target = target;
  newEvent.currentTarget = target;
  if (overrides) {
    newEvent = Object.assign(newEvent,overrides);
  }
  return mutationEventToString(newEvent);
}

async function runAllTests(state) {
  await testOne(state,'Node removal',[
      eventObj('DOMNodeRemoved','target',{relatedNode: parent}),
      eventObj('DOMNodeRemovedFromDocument','target',{bubbles:false})
    ],
    () => target.remove());

  await testOne(state,'Node append',[
      eventObj('DOMNodeInserted','target',{relatedNode: other}),
      eventObj('DOMNodeInsertedIntoDocument','target',{bubbles:false})
    ],
    () => other.appendChild(target));

  await testOne(state,'Create attribute',[
      eventObj('DOMSubtreeModified','target'),
    ],
    () => target.setAttribute('test','foo'));

  await testOne(state,'Change attribute value',[],
    () => target.setAttribute('test','bar'));

  await testOne(state, 'Change attribute value (direct)',[],
    () => {target.attributes[1].value = 'bar'});

  await testOne(state,'Remove attribute',[
      eventObj('DOMSubtreeModified','target'),
    ],
    () => target.removeAttribute('test'));

  await testOne(state,'Replace children',[
      eventObj('DOMNodeRemoved','Text node Hello',{relatedNode: target, currentTarget: target, eventPhase: 3}),
      eventObj('DOMSubtreeModified','target'),
      eventObj('DOMNodeInserted','Text node Hello there',{relatedNode: target, currentTarget: target, eventPhase: 3}),
      eventObj('DOMSubtreeModified','target'),
    ],
    () => target.replaceChildren(document.createTextNode('Hello there')));

  await testOne(state, 'Replace text content',[
      eventObj('DOMCharacterDataModified','Text node foo',{currentTarget: target, eventPhase: 3, newValue: 'foo', prevValue: 'Hello there'}),
      eventObj('DOMSubtreeModified','Text node foo',{currentTarget: target, eventPhase: 3}),
    ],
    () => target.firstChild.textContent = "foo");

  await testOne(state, 'Append child node',[
      eventObj('DOMNodeInserted','div', {relatedNode: target, currentTarget: target, eventPhase: 3}),
      eventObj('DOMSubtreeModified','target'),
    ],
    () => {
      const div = document.createElement('div');
      div.id = 'div';
      target.appendChild(div);
    });

  await testOne(state, 'Create child node attribute',[
      eventObj('DOMSubtreeModified','div',{currentTarget: target, eventPhase: 3}),
    ],
    () => div.setAttribute('foo','bar'));
}

testHarness();

</script>
